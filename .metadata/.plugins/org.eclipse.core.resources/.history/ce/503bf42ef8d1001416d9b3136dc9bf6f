package nju.edu.cn;

/**
 * 将两个有序表合并成一个有序表
 * @author eureka
 *
 */
public class MergeSort {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
	}
	
	//递归调用的方法
	public void mergeSort(int[] a, int start, int length) {
		
		if (a == null || ) {
			
		}
	}
	
	//将两个有序序列合并起来，可以参考两个有序链表的合并
	private void merge(int[] a, int startIndex, int midIndex, int endIndex) {
		int low = startIndex;
		int high = midIndex;
		int[] temp = new int[endIndex - startIndex + 1];
		int tempIndex = 0;
		
		while (low < midIndex && high <= endIndex) {
			if (a[high] < a[low]) {
				temp[tempIndex] = a[high];
				tempIndex++;
				high++;
			} else if (a[low] < a[high]){
				temp[tempIndex] = a[low];
				low++;
				tempIndex++;
			} else if (a[low] == a[high]) {
				temp[tempIndex] = a[low];
				low++;
				tempIndex++;
				temp[tempIndex] = a[high];
				high++;
				tempIndex++;
			}
		}
		
		while (low < midIndex) {
			temp[tempIndex] = a[low];
			low++;
			tempIndex++;
		}
		
		while (high < (midIndex+length)) {
			temp[tempIndex] = a[high];
			high++;
			tempIndex++;
			
		}
		
		System.arraycopy(temp, 0, a, startIndex, midIndex + length - startIndex);
	}

//	public class Solution {
//	    public List<String> findRepeatedDnaSequences(String s) {
//	        List<String> repeated = new ArrayList<String>();
//	        Set<String> repeatedSet = new HashSet<String>();
//	        
//	        if (s.length() <= 10) return null;
//	        
//	        for (int i = 0; i < s.length() - 10; i++) {
//	            String tempSub = s.substring(i, i + 9);
//	            String tempCon = s.substring(i+1, s.length() - 1);
//	            if (stringContained(tempCon, tempSub)) {
//	                repeatedSet.add(tempSub);
//	            }
//	        }
//	        
//	        repeated.addAll(repeatedSet);
//	        
//	        return repeated;
//	    }
//	    
//	    private boolean stringContained(String container, String subString) {
//	        return container.contains(subString);
//	    }
//	}
}
